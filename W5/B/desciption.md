# 问题描述

省流: 在线调度问题.

## 问题概述

现在, 你需要对 CPU 集群进行调度, 以便在给定的时间内完成所有任务. 你调度的粒度是一个时间片. 在每个时间片中, 一个 CPU 上只能执行一个任务.

对于每个任务, 其可以在任意一个 CPU 上执行, 但是**一旦开始执行, 不能中断或者重新执行, 直到保存完成, 才会计入贡献**. 需要注意, 一个任务的启动有一个 `kStartUp` 冷启动时间, 在保存的时候也有 `kSaving` 的保存时间. 实际运行时间计算的是两者中间的部分. 以下是一个任务的执行流程:

- `t0`: 启动某个任务.
- `t0 + kStartUp`: 任务开始执行.
- `t1`: 开始保存任务.
- `t1 + kSaving`: 任务保存完成.

一个流程是合法的, 当且仅当:

- `t0 + kStartUp <= t1`
- `t1 + kSaving <= deadline`

且计入的贡献部分是 `t1 - t0 - kStartUp`. 且在 `t0, t0 + 1, ... t1 - 1` 这段时间内, 任务都是在执行的, 即会占用 CPU 核心.

当然, 你可以将一个任务分配给多个 CPU 同时执行, 但是加速比 (有效核心数量) 并不是线性的. 具体请看 `definition.h` 里面的 `time_policy` 函数. 大致来讲, 假如有 k 个核心, 从启动到保存的时间差是 `t`, 那么加速比是 `pow(k, c) * (t - kStartUp)`, 其中 `c` 是一个常数.

### Generator side

你需要实现一个生成器, 具体函数签名参考 `interface.h`.

其中, 我们要求你返回一个任务列表, 且满足传入的 Description. 如果生成的列表不满足 Description, 则认为 generate 失败.

> 笔者注: 是否需要额外约束, 其中理论不可行的任务占比不能超过 50% 之类, 防止恶意生成? TODO

### Scheduler side

你需要实现一个调度器, 具体函数签名参考 `interface.h`.

其中, 我们提供了每个周期内新增的任务列表, 任务编号 (task_id) 默认从 0 开始. 同时, 我们也提供了和对应的 Generator side 一致的 Description. 你需要返回一个调度方案, 其中每个任务的执行时间段, 以及执行的 CPU 核心编号.

请注意, cpu 核心数有限, 如果超额使用直接认为 schedule 失败. 同样, 如果 task_id 超出当前给出的任务范围, 或者在做出非法调度 (比如在某个任务在 Saving 或者 Launch 的时候继续 Launch, 或者在不是 Launch 的时候 Saving), 也认为 schedule 失败.

## 一些其他的提示

我们下发与 OJ 几乎一致的相关文件. 你可以观察 `runtime.h` 来了解我们 OJ 具体测评相关的细节.

我们要求 gcc 的版本至少是 11, 编译参数请参考 `run.sh`. 如果你不会更新 gcc, 请问助教.

你可以在命令行输入 `sh run.sh` 来测试你的 `generator` 和 `scheduler` 的正确性. 在上传到 OJ 的时候, 你需要提交 `_generator.h` 以及 `_scheduler.h` 两个文件.
